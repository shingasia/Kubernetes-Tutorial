<style type='text/css'>
    .subject1 {
        font-size : 30px;
    }
    .subject2 {
        font-size : 27px;
        color : #80bfff;
    }
    .subtitle {
        font-size : 20px;
    }
    .yaml {
        background-color: #ffffff;
        color : #33cc33;
        font-weight : 700
    }
</style>
<hr/>
    <p class="subject1">쿠버네티스 오브젝트</p>
<hr/>
<p>쿠버네티스는 대부분의 리소스를 '오브젝트'라고 불리는 형태로 관리한다.</p>
<p>예를 들어 쿠버네티스에서는 컨테이너의 집합(Pods), 컨테이너의 집합을 관리하는 컨트롤러(Replica Set), 심지어 사용자(Service Account), 노드(Node)까지도 하나의 오브젝트로 사용할 수 있다.</p>

<ul> 쿠버네티스는 클러스터의 상태를 나타내기 위해 이 오브젝트를 이용한다. 구체적으로 말하자면, 다음같이 기술할 수 있다.
    <li>어떤 컨테이너화된 애플리케이션이 동작 중인지 (그리고 어느 노드에서 동작 중인지)</li>
    <li>그 애플리케이션이 이용할 수 있는 리소스</li>
    <li>그 애플리케이션이 어떻게 재구동 정책, 업그레이드, 그리고 내고장성(Fault-Tolerant)과 같은 것에 동작해야 하는지에 대한 정책</li>
</ul>
<p>쿠버네티스 오브젝트는 하나의 "의도를 담은 레코드"이다.</p>
<p>쿠버네티스 시스템은 그 오브젝트 생성을 보장하기 위해 지속적으로 작동할 것이다. 오브젝트를 생성함으로써, 사용자가 클러스터의 워크로드를 어떤 형태로 보이고자 하는지에 대해 효과적으로 쿠버네티스 시스템에 전달하는 이것이 바로 여러분의 클러스터에 대해 의도한 상태 가 된다.</p>

<p><span style="background-color:#ff0000; color:#ffffff">생성이든, 수정이든, 또는 삭제든 쿠버네티스 오브젝트를 동작시키려면, 쿠버네티스 API를 이용해야 한다.</span><br/>
예를 들어, kubectl 커맨드-라인 인터페이스를 이용할 때, CLI는 여러분 대신 필요한 쿠버네티스 API를 호출해 준다. 또한, 여러분은 클라이언트 라이브러리 중 하나를 이용하여 여러분만의 프로그램에서 쿠버네티스 API를 직접 이용할 수도 있다.</p>
<hr/>
<dl>
    <dt><p class="subject2">오브젝트 명세(spec)와 상태(status)</p></dt>
    <dd>거의 모든 쿠버네티스 오브젝트는 오브젝트의 구성을 결정해주는 두 개의 중첩된 오브젝트 필드 spec 과 status 를 포함한다</dd>
    <br/>
    <dd>spec 은 오브젝트를 생성할 때 리소스에 원하는 특징(desired state)에 대한 설명을 작성하여 설정한다.</dd>
    <dd>status 는 쿠버네티스 시스템과 컴포넌트에 의해 제공되고 업데이트된 오브젝트의 현재 상태(current state) 를 설명한다.</dd>
    <br/>
    <dd style="color:#ff471a">쿠버네티스 컨트롤 플레인은 모든 오브젝트의 실제 상태를 사용자가 의도한 상태와 일치시키기 위해 끊임없이 그리고 능동적으로 관리한다.</dd>
    <hr/>
    <dt><p class="subject2">쿠버네티스 오브젝트 기술하기</p></dt>
    <dd>쿠버네티스에서 오브젝트를 생성할 때, (이름과 같은)오브젝트에 대한 기본적인 정보와 더불어, 의도한 상태를 기술한 오브젝트 spec을 제시해 줘야만 한다.</dd>
    <br/>
    <dd>
        <pre class="yaml deployment">
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80
        </pre>
    </dd>
    <br/>
    <dd>위 예시와 같이 YAML 또는 JSON 파일을 이용하여 디플로이먼트를 생성하기 위한 하나의 방식으로는 kubectl apply 명령을 이용한는 것이다.</dd>
    <dd><span style="color:#cc3399">$ kubectl apply (-f FILENAME | -k DIRECTORY)</span></dd>
    <hr/>
    <dt><p class="subject2">필수로 있어야 하는 필드</p></dt>
    <ul>생성하고자 하는 쿠버네티스 오브젝트에 대한 .yaml 파일에 다음 필드를 위한 값들을 설정해 줘야한다.
      <li>apiVersion - 이 오브젝트를 생성하기 위해 사용하고 있는 쿠버네티스 API 버전이 어떤 것인지</li>
      <li>kind - 어떤 종류의 오브젝트를 생성하고자 하는지</li>
      <li>metadata - 이름 문자열, UID, 네임스페이스를 포함하여 오브젝트를 유일하게 구분지어 줄 데이터</li>
      <li>spec - 오브젝트에 대해 어떤 상태를 의도하는지</li>
    </ul>
    <dd>오브젝트 spec에 대한 정확한 포맷은 모든 쿠버네티스 오브젝트마다 다르고, 그 오브젝트 특유의 중첩된 필드를 포함한다.</dd>
</dl>



